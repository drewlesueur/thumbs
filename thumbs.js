//Future thumbs implementation based off more gotos.
// may need to do more of a bytecode type implementation
// double line numbers, one for source and one for generated bytecode

;(function () {
var root = this;
var thumbs;
if (typeof exports !== 'undefined') {
  thumbs = exports;
  thumbs.global = global
} else {
  thumbs = root.thumbs = {};
  thumbs.global = window
}

var lineNumber;

var globalScope = thumbs.scope = {
  b: "400"
}

var killSignal = "stooooooop!!!!!";
var callStack = []
var instructionSet = {
  set: function (a, b, scope) {
    scope[a] = b;
    return b;
  },
  get: function (b, scope) {
    if (b - 0 == b) { // && not prop access
      return b - 0;
    }
    if (b.charAt(0) == "$") {
      return b.substring(1);
    }
    return scope[b]
  },
  stop: function () {
    return killSignal;
  },
  assert: function (a, b, scope) {
    if (a != b) {
      var line = files[lastFile][lastLine];
      throw new Error(a + " doesn't equal " + b + " on line " + (lastLine + 1) + "(bytecode "+(lastBytecodeLine + 1)+")" + ": \"" + line + "\" of \"" + lastFile + "\"")
    } 
  },
  say: function (what) {
    console.log(what)  
  },
  call: function (func, outputVar, scope) {
    var line = func[0];
    var funcScope = func[0]
    callStack.
    pc = line; 

  },
  "return": function () {
     
  },
  fn: function (line, name, scope) {
    scope[name] = [line, scope]  
  },
  goto: function () {},
  "debugger": function () {}
}

lastFile = ""
lastLine = 0
lastBytecodeLine = 0
files = {}
labels = {} 
labelChar = "["

var assignLabels = function (lines, filename, scope) {
  labels[filename] = {}
  var filenameLabels = labels[filename]
  for (var i = 0; i < lines.length; i++) {
    line = lines[i];
    if (line.charAt(0) == labelChar) {
      var label = line.substring(1, line.length - 1)
      filenameLabels[label] = i;
    }
  }
}


var removeNestings = function (code) {
  var code = code.split("")
  var i = 0;
  var state = "normal";
  var indent = 0;
  var doMultiLineString = function () {
    var str = [];
    //find next indent that is the same as the current
    var strIndent = indent + 1;
    i += 1
    while (true) {
      chr = "\n "  
    }
     
  }
 
  while (i < code.length) {
    var chr = code[i];
    if (state == "normal") {
      if (chr == "'") state = "sart-quote";
    }  else if (state == "startquote") {
       if (ch == " ") doMultiLineString();
    }
  } 
}

var compile = function (code, filename, scope) {
  var compiled = []
  //right now just going to compile the bytecode subset
  // that can be put into thumbs source
  code = removeNestings(code);
  var lines = code.split("\n");
  files[filename] = lines;
  var line, words, first, func;
  //once throught getting all the labels
  assignLabels(lines, filename, scope);
  
  code = code.join("\n")
  for (var i = 0; i < lines.length; i++) {
    line = lines[i] 
    var firstChar = line.charAt(0);
    if (firstChar == ";") {
      words = line.split(" ");
      first = words[0].substring(1)
      words[0] = instructionSet[first];
      for (var wordsIndex = 1; wordsIndex < words.length; wordsIndex++) {
        var word = words[wordsIndex];
        if (word.charAt(0) == labelChar) { //"["
          var label = word.substring(1, word.length - 1)
          var labelValue = labels[filename][label];
          words[wordsIndex] = labelValue;
        } 
      }
      words.push(filename, i); //every instruction also has original file name and line
      compiled.push(words)
    } else if (firstChar == "/") {
      continue 
    }
  }
  return compiled;
}

var run = function (code, filename, scope) {
  scope = scope || globalScope
  bytecodes = compile(code, filename, scope);
  interpretBytecode(bytecodes, scope);
}

var getLineStr = function () {
  var line = files[lastFile][lastLine];
  return line;
}

var pc = 0; //program counter
var interpretBytecode = function (bytecodes, scope) {
  var line, fn, args, ret;
  var scope = scope || globalScope
  var bytecodesLength = bytecodes.length
  while (pc < bytecodesLength) {
    line = bytecodes[pc];
    fn = line[0]; 
    args = line.slice(1);
    var argsLength = args.length
    lastFile = args[argsLength - 2]
    lastLine = args[argsLength - 1]
    lastBytecodeLine = pc
    if (fn == instructionSet.debugger) {
      debugger; 
    }
    var evaledArgs = [];
    var arg, evaledArg;
    //all but the last two, they are the file and the line number
    for (var argsIndex = 0; argsIndex < argsLength - 2; argsIndex++) {
      arg = args[argsIndex]; 
      evaledArg = instructionSet.get(arg, scope);
      evaledArgs.push(evaledArg);
    }
    //TODO: is there a better way
    //to keep track of last file? maybe with regions?

    evaledArgs.push(scope);
    //evaledArgs.push([name, ]);
   
    ret = fn.apply(null, evaledArgs) //when implementing in other languages, you may have to pass in array of params
    if (ret == killSignal) {
      break; 
    }
    pc += 1
  }
  return ret
}

var runFile = function (file) {
  var fs = require("fs");
  var code = fs.readFileSync(file).toString();
  var ran = run(code) 
  return ran;
}    

var addScope = function (obj) {
  for (var i in obj) {
    rawScope[i.toLowerCase()] = obj[i] 
  }  
}

thumbs.runScripts = runScripts
thumbs.run = run //runs raw code
thumbs.runFile = runFile
thumbs.addScope = addScope
thumbs.getLineStr = getLineStr

//borrowed from
//https://raw.github.com/jashkenas/coffee-script/master/src/browser.coffee

if (typeof window === "undefined" || window === null) return;

thumbs.load = function(url, callback) {
  var xhr;
  xhr = new (window.ActiveXObject || XMLHttpRequest)('Microsoft.XMLHTTP');
  xhr.open('GET', url, true);
  if ('overrideMimeType' in xhr) xhr.overrideMimeType('text/plain');
  xhr.onreadystatechange = function() {
    var _ref;
    if (xhr.readyState === 4) {
      if ((_ref = xhr.status) === 0 || _ref === 200) {
        thumbs.run(xhr.responseText, url);
      } else {
        throw new Error("Could not load " + url);
      }
      if (callback) return callback();
    }
  };
  return xhr.send(null);
};

var runScripts = function() {
  var thumbses, execute, index, length, s, scripts;
  scripts = document.getElementsByTagName('script');
  thumbses = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = scripts.length; _i < _len; _i++) {
      s = scripts[_i];
      if (s.type === 'text/thumbs') _results.push(s);
    }
    return _results;
  })();
  index = 0;
  length = thumbses.length;
  (execute = function() {
    var script;
    script = thumbses[index++];
    if ((script != null ? script.type : void 0) === 'text/thumbs') {
      if (script.src) {
        return thumbs.load(script.src, execute);
      } else {
        thumbs.run(script.innerHTML.slice(1), "scripttag" + (index - 1));
        return execute();
      }
    }
  })();
  return null;
};

if (window.addEventListener) {
  addEventListener('DOMContentLoaded', runScripts, false);
} else {
  attachEvent('onload', runScripts);
}
})();

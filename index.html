<!doctype html>
<head>
<meta name="viewport" content="initial-scale = 1.0" />
<style>
  * {
    font-family: Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Mono', 'Monospace'
  }
</style>
<script type="text/x-thumbs">
  Is 1 2 *
    Say $ yes! 

  Is 2 10 *
    Say $ 2 is 10:

    
</script>
<script type="text/x-thumbs2">
log * message
  Say $ log: $message

greet * person
  Say $ welcome $person , How are you?

Greet $friend

band #
  name $Aterciopelados
  members #
    first $Andrea
    second $Hector

Log band.members.second



</script>

<script type="text/x-thumbs2">
$ fx strings
$ lists
$ call js funciton
$ getter setter lookup / no just make functions able to be called with .
$ add reference to caller scope
$ set parent on object to lookup
$ property missing object?prop
$ conect everything by function calls
$ todo make it async! calling a function should be async. getting should be async
$ at least async-able. you can use callbacks, but call it right away when not debugging? or figure something out
$ no, just have an array of things to execute.


argTest * a b c d e
  a $ $a $b $c $d $e

t ArgTest $h $e $l $l $o
Eq t $ h e l l o

myFn * a b
  B 1 2

three MyFn
  0
  * x y
    Add x y
Eq three 3

myFn * a b c d
  C a b d

three MyFn
  0
  1
  * x y z
    Add x y z
  4 5 6

Eq three 5


$ --------

$ defining a function
adding * x y
  Add x y

$ setting a variable to the result of a function call
added Adding 1 5
Eq added 6

$ showing calling functions in a row
negative Neg Add 5 6
Eq negative -11

$ a closure
incmaker *
  x 0
  inc *
    x Add 1 x

inc Incmaker
a Inc
b Inc
c Inc
Eq a 1
Eq b 2
Eq c 3

$ closure without stars for functions
incmaker2
  x 10
  inc
    x Add 2 x

$ coffeescript version
  incMaker = ->
    x = 10
    inc = ->
      x = x + 2

inc2 Incmaker2
a Inc2
b Inc2
c Inc2
Eq a 12
Eq b 14
Eq c 16

$ multiline strings
multiliner $
  My name is Drew!
  This should be multi line
Say multiliner

$ interpolation of strings
name $ Drew LeSueur
age 27
info $ $name is $age years old.
realInfo $ Drew LeSueur is 27 years old.
Eq info realInfo


$ assigning one variable to another
answer 2001
theAnswer answer
Eq theAnswer 2001
Eq answer 2001

$ maps (hashes)
nose $notCarrots
snowman #
  name $ Mr. Snowman
  nose $carrots
  numberofcoals Add 2 4

snowmanName $ Mr. Snowman
Eq snowman.name snowmanName
Eq nose $notCarrots
Eq snowman.nose $carrots
Eq snowman.numberOfCoals 6

myProp $nose
Eq snowman:myProp $carrots

band #
  name $Aterciopelados
  members #
    first $ Andrea Echeverri
    second $ Hector Buitrago
  cds #
    caribe #
      name $ caribe atomico
      art $ shark

andrea $ Andrea Echeverri
Eq band.members.first andrea

prop $cds
Eq band:prop.caribe.art $shark
prop2 $name
caribe $ caribe atomico
Eq band:prop.caribe:prop2 caribe

$ todo: do this
  person #
  person.name $ Drew LeSueur
  Eq person.name $ Drew LeSueur

$ todo: do this to
  MyCoolFunc a b
    c d e


$ TODO: something like this (look at nestedArgs when you are compiling a func)
  SomeFuncCall
    #
      fun $times
    * success
      DO the success
    * error
      DO the error
    $
      the string stuff
    anotherArg andAnotherArg
    andAnother
    AndAFunctionCall forArg
   
  Loop collection * x
    print x

  Loop collection
    * x
      do something

$ assigning a function to another and calling it      
action adding    
result Action 11 12
Eq 23 result

$ passing a function as a parameter to another function
doThisThing * fn b c
  Fn b c
dalmations DoThisThing adding 100 1
Eq dalmations 101

doThisThing2 * a b fn
  Fn a b
sheep DoThisThing2 90 9 * c d
  Adding c d 
Eq sheep 99

sendText * text
  ret $ a text was sent to $text.to from $text.from

$  todo: non interpolating strings

status SendText #
  from $drew
  to $aimee

Eq status $ a text was sent to aimee from drew

$ TODO: tail call optimization

saying * message
  Say message

adding2 * a b c d e f
  Add a b c d e f
ret Adding2
  1 2
  3 4
  5 6
Eq ret 21

ret Add
  1 2
  3 4
  5 6
Eq ret 21


ret Add
  Add 1 2
  3
  Add 4 5
Eq ret 15


argTest2 * a b c d e
  a $ $a $b $c $d $e
  a

t ArgTest2 $h $e $l $l $o
Eq t $ h e l l o

$ todo: these
argTest3 * a b c d e
  $ $a $b $c $d $e
t ArgTest3 $h $e $l $l $o
Eq t $ h e l l o

argTest4 * a b c d e
  $ $a $b $c $d $e
t ArgTest4 
  $h $e $l
  $l $o
Eq t $ h e l l o


Saying $ almost done

Say $ all done

</script>

<script type="text/x-thumbs-2">
myProp $eyes
person:myProp
person.eyes
Eq person.eyes person:myProp

incMaker *
  x 0
  inc *
    x Add 1 x

inc IncMaker
x Inc
Say x
x Inc
Say x


</script>
<script type="text/x-thumbs-2">
$ everything is a function that does what it does??
$ or simple goto
mytext $
  this is a totally cool
  string that is verry long

mytext2 $ this is another text not as big

message $ hi
Say message
Say $HelloWorld
sayHi * name age
  Say age

snowman #
  eyes $carrots
  body $snow

snowman.mouth $pipe


mylist + long list of stuff

myname $ Drew LeSueur
myage 27
SayHi myname myage

answer Add 7 5

</script>
<script type="text/javascript">

  var splitText = function (text) {
    text = text.split(" ");
    return text
  }

  var parse = function(configs) {
    var a, b, config, currentObj, currentSpaceLen, final, i, lastIndex, lastThingAdded, match, newCurrentObj, objectStack, ret, spaceLen, text, _i, _len, _ref;
    configs = configs.split("\n");
    final = {};
    currentSpaceLen = -2;
    lastThingAdded = ["do"];
    currentObj = [lastThingAdded];
    lastIndex = 0;
    objectStack = [currentObj];
    for (_i = 0, _len = configs.length; _i < _len; _i++) {
      config = configs[_i];
      match = config.match(/^(\s*)([^\s].*)/);
      if (!match) continue;
      if ((match != null ? match.length : void 0) < 3) continue;
      spaceLen = match[1].length / 2;
      text = match[2];
      text = splitText(text)
      text.unshift(_i) // for line numbers
      if (spaceLen === currentSpaceLen) {
        currentObj.push(text);
        lastThingAdded = text;
        lastIndex = currentObj.length - 1;
      } else if (spaceLen > currentSpaceLen) {
        currentSpaceLen = spaceLen;
        newCurrentObj = [lastThingAdded];
        currentObj[lastIndex] = newCurrentObj;
        currentObj = newCurrentObj;
        currentObj.push(text);
        lastThingAdded = text;
        lastIndex = currentObj.length - 1;
        objectStack.push(currentObj);
      } else if (spaceLen < currentSpaceLen) {
        for (i = 0, _ref = currentSpaceLen - spaceLen; 0 <= _ref ? i <= _ref : i >= _ref; 0 <= _ref ? i++ : i--) {
          currentObj = objectStack.pop();
        }
        try {
          currentObj.push(text);
        } catch (e) {

        }
        objectStack.push(currentObj);
        currentSpaceLen = spaceLen;
        lastThingAdded = text;
        lastIndex = currentObj.length - 1;
      }
    }
    window.os = objectStack;
    window.co = currentObj;
    ret = objectStack[0] || currentObj;
    return ret[0];
  };

  var rawScope = {
    "is": function (a, b, c) {
      if (a == b) {
        c()         
      } 
    },
    "say": function (x) {
       console.log(x)
    },
    "do": function () {},
    "add": function () {
      var sum = 0;
      for (var i = 0; i < arguments.length; i++)
        sum += arguments[i] 
      return sum;
    },
    eq: function (a, b) {
      if (a != b) {
        console.log(a + " isn't " + b + " on line " + lineNumber) 
      }  
    },
    neg: function (a) {
      return -a 
    }
  }  

  var scope = {
    body: rawScope,
    parentScope: null
  }

  window.scope = scope;
  var currentScope = scope;
  var scopeStack = [];
  window.scopeStack = scopeStack;
  window.currentScope = currentScope;

  var ObjProto = Object.prototype
  var toString = ObjProto.toString
  var isFunction = function (obj) {
    return toString.call(obj) == '[object Function]';
  }
  var isObject = function (obj) {
    return obj === Object(obj);
  }

  var __slice = Array.prototype.slice;
  var slice = __slice;
  var __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
  var nativeBind = Function.prototype.bind 
  var ctor = function() {}
  __bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };


  var setString = function (rest, nestedArgs, currentScope) {
    for (var i = 0; i < nestedArgs.length; i++) {
      nestedArgs[i] = nestedArgs[i].slice(1).join(" ") //slice to remove line number
    } 
    var value = rest.join(" ") 
    value += nestedArgs.join("\n")
    value = value.replace(/\$([^\s]+)/g, function (whole, word) {
      return get(word, currentScope) 
    })
    return value;
  }
  var setNumber = function (second) {
    var value = second - 0 
    return value
  }


  var setFunction = function (rest, nestedArgs, currentScope) {
    var value = {
      scope: currentScope,
      type: "fn",
      args: rest,
      body: nestedArgs
    }
    return value
  }


 //   } else if (isStartSymbol(second)) {
 //     var theArg = generateValue(second, rest, nestedArgs)


  //TODO: add a unique id
  var setMap = function (nestedArgs, currentScope) {
    //TODO: hmmmm!!! 
    var fn = setFunction([], nestedArgs, currentScope);
    var opts = {
      onlySetInCurrentScope: true      
    }
    //TODO: call compiledFunction here
    var retScope = {body: {}, parentScope: currentScope}
    var compiled = {
      scope: retScope,
      body: fn.body
    }
    callThumbsFunction(compiled, opts)
    delete retScope.parentScope;
    var value = {
      type: "map",
      body: retScope.body,
      parentScope: "", //TODO: should object
      getters: "", //?
      setters: "", //?
      notFound: "", //?
    }
    return value
  }


  var findScopeWithName = function(name, lookupScope, originalLookupScope) {
    originalLookupScope = originalLookupScope || lookupScope
    if (name in lookupScope.body) {
      return lookupScope
    } else if (lookupScope.parentScope) {
      return findScopeWithName(name, lookupScope.parentScope, originalLookupScope) 
    } else {
      return originalLookupScope 
    }
  }

  
  var generateValue = function (second, rest, nestedArgs, currentScope) {
    if (second == "$") { //todo. do a faster way of converting to string //cache or something
      value = setString(rest, nestedArgs, currentScope)
    } else if (second == "*") {
      value = setFunction(rest, nestedArgs, currentScope)
    } else if ((second - 0) == second) {
      value = setNumber(second) 
    } else if (second && second.match(/^[A-Z]/)) {
      value = setFuncCall(second, rest, nestedArgs, currentScope); 
    } else if (!second && nestedArgs.length) {
      value = setFunction(rest, nestedArgs, currentScope) 
    } else if (second == "#") {
      value = setMap(nestedArgs, currentScope);
    } else {
      value = get(second, currentScope) 
    }
    return value;
  }

  var setValue = function (first, second, rest, nestedArgs, currentScope, opts) {
    if (!second && !nestedArgs.length) {
      return get(first, currentScope)
    }
    //TODO: pass in first and rest and nested args and stuff
    var value = generateValue(second, rest, nestedArgs, currentScope);
    return set(first, value, currentScope, opts)
  }

  var set = function (name, value, currentScope, opts) {
    name = name.toLowerCase()
    if (opts && opts.onlySetInCurrentScope) {
      var settingScope = currentScope;
    } else {
      var settingScope = findScopeWithName(name, currentScope)
    }
    settingScope.body[name] =  value;
    //todo make an option for always setting the current scope
    //like var is in javascript
    return value
  }
  
  var callInRestIfNeeded = function (rest) {
    if (!rest[0]) return;
    if (rest[0].match(/^[A-Z]/)) {
        
    }
  } 
   
  var convertArgs = function (argsIndex, args, newScope, fn, rest, nestedArgs, currentScope, opts ) {
    var foundInnerObject = false;
    //TODO: optimize this because the fn calling this one has already com
    //combined second and rest 
    
    if (rest.length) {
      var second = rest[0]
      var rest = rest.slice(1)
      if (second && second.match && second.match(/^[A-Z]/)) {
        var ret = callFunction(second, rest[0], rest.slice(1), nestedArgs, currentScope)
        var rest = [ret];
      } else {
        var rest = [second].concat(__slice.call(rest))
      }
    }

    for (var i = 0; i < rest.length; i++) {
      var varName = rest[i]
      if (isStartSymbol(varName)) { //should I be doing this?
        var theRest = rest.slice(i+1)
        var argValue = generateValue(varName, theRest, nestedArgs, currentScope)
        foundInnerObject = true;
      }
      if (fn.args) {
        var argVarName = fn.args[i + argsIndex] 
      }
      if (!foundInnerObject) {
        var argValue = get(varName, currentScope)
      }
      args.push(argValue);
      if (argVarName) {
        newScope.body[argVarName] = argValue;
      }
      if (foundInnerObject) {
        argsIndex += 1
        break;
        
      }
      
    } 
    newScope.body.args = args;
    return  {
      foundInnerObject: foundInnerObject,
      argsIndex: argsIndex + i
    }
  }

  var convertJSArgsToThumbsArgs = function (args) {
    
  }

  //TODO: add objects, whats the best way? 
  // should I treat them like functions?
  // or should I just try to convert to js object
  var convertThumbsArgsToJSArgs = function(args, currentScope) {
    for (var i = 0; i < args.length; i++) {
      var arg = args[i]
      if (arg.type == "fn") {
        var rest = []; // for now
        var nestedArgs = []; //
        var compiledFunction = compileFunction(arg, rest, nestedArgs, currentScope) 
        args[i] = function () {
          callThumbsFunction(compiledFunction)  
        }
      }   
    }  
  } 

  var compileFunction = function (fn, rest, nestedArgs, currentScope, opts) {
    //TODO: some of this compiling could be done when it
    //first parses?
    // or cache some of this stuff here

    var newScope = {
      body: {},
      parentScope: fn.scope //js func wont have scope but oh well
    }

    var args = [];
    var argsIndex = 0;
    convertArgsInfo = convertArgs(argsIndex, args, newScope, fn, rest, nestedArgs, currentScope, opts)

    function isThisTheBestWayToHandleNestedArgs() {
      var argsIndex = convertArgsInfo.argsIndex
      foundInnerObject = convertArgsInfo.foundInnerObject

      if (!foundInnerObject && nestedArgs.length) {
        for (var i = 0; i < nestedArgs.length; i++) {
          var newNestedArg = []
          var nestedArg = nestedArgs[i]
            if (nestedArg[0] - 0 !== nestedArg[0]) {
              var newNestedArg = nestedArg.slice(1) 
              nestedArg = nestedArg[0].slice(1)
            } else {
              nestedArg = nestedArg.slice(1) // see line = line[0] self similar?
            }
          convertArgsInfo = convertArgs(argsIndex, args, newScope, fn, nestedArg, newNestedArg, currentScope, opts)
          argsIndex = convertArgsInfo.argsIndex
          //foundInnerObject = convertArgsInfo.foundInnerObject
        }
      }
    }
    isThisTheBestWayToHandleNestedArgs()

    var args = newScope.body.args
    if (isFunction(fn)) {
      convertThumbsArgsToJSArgs(args, currentScope);
      //TODO: convert args to js equivalents!! helpful for settimeout, callbacks etc
      //var compiled = __bind(fn, null, args);
      var compiled = __bind.apply(null, [fn, null].concat(__slice.call(args)))
      // __bind fn, null, args... 
    } else {
      var compiled = {
        scope: newScope,
        body: fn.body
      }
    }
    return compiled;
  }

  var callThumbsFunction = function (compiled, opts) {
    console.log("Calling a function")
    //TODO: some of this stuff should be cached per function?
    //maybe solving it now with compileFunction call
    //calljs func should be similar to this
    //todo: maybe get rid of opts
    var ret
    if (isFunction(compiled)) {
      ret = compiled()
    } else {
      ret = runParsed(compiled.body, compiled.scope, opts)
    }
    console.log("done calling a function")
    return ret;
  }
  
  var setFuncCall = function (second, rest, nestedArgs, currentScope) { //todo: maybe pass arguments here 
    // locally scoped variables
    var name = first  
    var first = second
    var second = rest[0]
    var rest = rest.slice(1)
    var value = callFunction(first, second, rest, nestedArgs, currentScope)
    return value;
  }
  
  var isStartSymbol = function (thing) {
    return thing && thing.match && thing.match(/^[\*|\#|\$|\+]$/) 
  } 
  //TODO? pass currentScope in here?
  var callFunction = function (first, second, rest, nestedArgs, currentScope) {
    var fn = get(first.toLowerCase(), currentScope) 
    if (second) { 
      var rest = [second].concat(__slice.call(rest))
    }
    var compiledFunction = compileFunction(fn, rest, nestedArgs, currentScope) 
    return callThumbsFunction(compiledFunction)  
  }
  


  var chainGet = function (names, symbols, lookupScope, originalScope) {
    if (names.length == 0) {
      return lookupScope;
    }
    var name = names[0]
    var symbol = symbols[0];
    var names = names.slice(1)
    var symbols = symbols.slice(1)
    if (symbol == ":") { //either . or :
      name = get(name, originalScope) 
    }
    var value = get(name, lookupScope)
    return chainGet(names, symbols, value, originalScope);
  }


  //TODO: get can be an object! change
  //TODO: also include getter and setter options
  var get = function (name, lookupScope) {
    lookupScope = lookupScope || currentScope;

    if (!name) {
      return name
    }

    if (isObject(name)) {
      var a = 1; 
    }
    
    try {
      if (name.charAt && name.charAt(0) == "$") {
        return name.substring(1) 
      } else if (name - 0 == name) {
        return name - 0
      }
      name = name.toLowerCase()
    } catch (e) {
      var b = 1; 
    }

    var names = name.split(/\.|\:/)
    if (names.length > 1) {
      var symbols = name.match(/\.|\:/g)
      symbols.unshift(".")
      return chainGet(names, symbols, lookupScope, lookupScope)
    }

    if (name in lookupScope.body) {
      return lookupScope.body[name] 
    } else if (lookupScope.parentScope) {
      return get(name, lookupScope.parentScope) 
    } else {
      return null;
    }
  } 

  var execLine = function (line, currentScope, opts) {
    var nestedArgs = []
    if (line[0] - 0 === line[0]) {
      //no nested args
    } else {
      nestedArgs = line.slice(1)   
      line = line[0];
    }
    lineNumber = line[0]
    execingLine(lineNumber)
    var first = line[1];
    var second = line[2];
    var rest = line.slice(3);
    var value; 

    
    originalLine = originalLines[lineNumber]
    if (originalLine == "  Fn b c") {
      var bp = 1;
    }
    if (first == "$") {

      var theRest = [second].concat(__slice.call(rest))
      var value = generateValue(first, theRest, nestedArgs, currentScope);
      return value;
    } else if (first.match(/^[a-z]/)) {
      return setValue(first, second, rest, nestedArgs, currentScope, opts)
    //} else if (first.match(/^[a-z]/) && !second) {
    //  return get(first, currentScope)
    } else if (first.match(/^[A-Z]/)) {
      return callFunction(first, second, rest, nestedArgs, currentScope)
    }
  }
  
  var originalLines;
  var parsed;
  
  var queue = []
  var queueIndex = 0;
  var startTimer = function () {
    
    var f
    setInterval(function () {
      f = queue[queueIndex]
      f && f();
      queueIndex += 1
    }, 1000)   
  }
  var loop = function (items, cb) {
    var section = []
    for (var i=0; i < items.length; i++) {
       var item = items[i]
       cb(item, i) 
       //var f = __bind(cb, null, item, i)
       //section.push(f)
    }
    section.unshift(0)
    section.unshift(queueIndex + 1)
    queue.splice.apply(queue, section)
  }

  var runParsed = function (parsed, theScope, opts) {
     theScope = theScope || currentScope
     var last;
     loop(parsed, function (line, i, cb) {
       last = execLine(line, theScope, opts);
     })
     return last
  }
  
  var lastLine = null;
  var execingLine = function (lineNumber) {
    lastLine && lastLine.classList.remove("selected")
    var line = document.querySelector('[data-line="'+lineNumber+'"]') 
    line.classList.add("selected")
    lastLine = line
    scrollTo(0, line.offsetTop - 100)
  }

  var run = function (code) {
    parsed = parse(code);
    originalLines = code.split("\n")
    parsed = parsed.slice(1)
    addUI(originalLines)
    runParsed(parsed);
    startTimer()
  }

  var addUI = function () {
    var codeEl = document.querySelector('#code')
    for (var i = 0; i < originalLines.length; i++) {
      var lineEl = document.createElement('pre')   
      lineEl.setAttribute("class", "line")
      lineEl.setAttribute('data-line', i)
      codeEl.appendChild(lineEl)
      var line = originalLines[i]
      line = line.replace(/^([\s]*)([a-z][\w]+)/, function (all, s, w) {
        return s + "<span class='set'>" + w + '</span>'
      })
      line = line.replace(/^([\s]*)([A-Z][\w]*)/, function (all, s, w) {
        return s + "<span class='call'>" + w + '</span>'
      })
      line = line.replace(/^([\s]*)([A-Z][\w]*)/, function (all, s, w) {
        return s + "<span class='call'>" + w + '</span>'
      })
      line = line.replace(/^([\s]*)([\$].*)/, function (all, s, w) {
        return s + "<span class='text'>" + w + '</span>'
      })
      line = line.replace(/[\$][^\s]+/, function (all, s, w) {
        return "<span class='text'>" + all + '</span>'
      })
      lineEl.innerHTML = line
       
    }
  }

  var start = function () {
    var codes = document.querySelectorAll('[type="text/x-thumbs"]')
    for (var i = 0; i < codes.length; i++) {
      var code = codes[i].innerHTML.slice(1)
      run(code)
    }
    //console.log(parsed)
    //console.log(scope)

  }
</script>
<script type="text/x-todo">
  <h1>Thumbs. A simple programming language</h1>
  What the symbols mean
  <pre class="legend" style="font-size: 40px">
  * function
# map (hash)
  + list (array)
  $ text (string)
  </pre>

  A Hello world


  //todo. objects as keys
  //todo. splats! and create a new function with scope
  //dynamically set a variable to the current scope
  // getters and setters. and propertymissings
  // allow for easy "Say $ hello wolrd"
  //one more level of indirection for strings and numbers?
  //tail call optimization
</script>
<link rel="stylesheet" href="dejavu/stylesheet.css" type="text/css" charset="utf-8">
<style>
  * {
		font-family: 'DejaVuSansMonoBook';
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  textarea {
  font-size: 16px;
  margin-right: 10%; width:90%; height:2000px;
  }
  .set {
    color: blue;  
  }
  .call {
    color: #00AA00;  
  }
  .text {
    color: #AA0000;
		font-family2: 'HoeflerText-Regular';
  }

  .selected { background-color: rgb(0,255,255); }

#code {
  font-size: 16px;
  margin-right: 10%; width:90%; height:2000px;
}
.line {
  
}
</style>
</head>
<body onload="start()">
  <div id="code" style="">
  
  </div>

</body>
</html>



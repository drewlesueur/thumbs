//Future thumbs implementation based off more gotos.
// may need to do more of a bytecode type implementation
// double line numbers, one for source and one for generated bytecode

;(function () {
var root = this;
var Thumbs;
if (typeof exports !== 'undefined') {
  Thumbs = exports;
  Thumbs.global = global
} else {
  Thumbs = root.Thumbs = {};
  Thumbs.global = window
}

var lineNumber;

var globalScope = Thumbs.scope = {
  b: "400"
}

var killSignal = "stooooooop!!!!!";
var instructionSet = {
  set: function (a, b, scope) {
    scope[a] = b;
    return b;
  },
  get: function (b, scope) {
    if (b - 0 == b) { // && not prop access
      return b - 0;
    }
    if (b.charAt(0) == "$") {
      return b.substring(1);
    }
    return scope[b]
  },
  stop: function () {
    return killSignal;
  },
  assert: function (a, b) {
    console.log(asserting)
    if (a != b) {
      throw new Error(a + " doesn't equal " + b)
    } 
  }
}

var compile = function (code) {
  var compiled = []
  //right now just going to compile the bytecode subset
  // that can be put into thumbs source
  var lines = code.split("\n");
  var line, words, first, func;
  for (var i = 0; i < lines.length; i++) {
    line = lines[i] 
    if (line.charAt(0) == ";") {
      words = line.split(" ");
      first = words[0].substring(1)
      words[0] = instructionSet[first];
      compiled.push(words);
    }
  }
  return compiled;
}

var run = function (code, name, scope) {
  scope = scope || globalScope
  console.log("running code")
  console.log(code)
  bytecodes = compile(code);
  console.log(bytecodes)
  interpretBytecode(bytecodes, name, scope);
}

var interpretBytecode = function (bytecodes, name, scope) {
  var line, fn, args, ret;
  var scope = scope || globalScope
  for (var i=0; i<bytecodes.length; i++) {
    line = bytecodes[i];
    fn = line[0]; 
    args = line.slice(1);
    var evaledArgs = [];
    var arg, evaledArg;
    for (var argsIndex = 0; argsIndex < args.length; argsIndex++) {
      arg = args[argsIndex]; 
      evaledArg = instructionSet.get(arg, scope);
      evaledArgs.push(evaledArg);
    }
    evaledArgs.push(scope);
    evaledArgs.push([name, ]);
   
    ret = fn.apply(null, evaledArgs) //when implementing in other languages, you may have to pass in array of params
    return ret;
  }
}

var runFile = function (file) {
  var fs = require("fs");
  var code = fs.readFileSync(file).toString();
  var ran = run(code) 
  return ran;
}    

var addScope = function (obj) {
  for (var i in obj) {
    rawScope[i.toLowerCase()] = obj[i] 
  }  
}

Thumbs.runScripts = runScripts
Thumbs.run = run //runs raw code
Thumbs.runFile = runFile
Thumbs.addScope = addScope

//borrowed from
//https://raw.github.com/jashkenas/coffee-script/master/src/browser.coffee

if (typeof window === "undefined" || window === null) return;

Thumbs.load = function(url, callback) {
  var xhr;
  xhr = new (window.ActiveXObject || XMLHttpRequest)('Microsoft.XMLHTTP');
  xhr.open('GET', url, true);
  if ('overrideMimeType' in xhr) xhr.overrideMimeType('text/plain');
  xhr.onreadystatechange = function() {
    var _ref;
    if (xhr.readyState === 4) {
      if ((_ref = xhr.status) === 0 || _ref === 200) {
        Thumbs.run(xhr.responseText, url);
      } else {
        throw new Error("Could not load " + url);
      }
      if (callback) return callback();
    }
  };
  return xhr.send(null);
};

var runScripts = function() {
  var thumbses, execute, index, length, s, scripts;
  scripts = document.getElementsByTagName('script');
  thumbses = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = scripts.length; _i < _len; _i++) {
      s = scripts[_i];
      if (s.type === 'text/thumbs') _results.push(s);
    }
    return _results;
  })();
  index = 0;
  length = thumbses.length;
  (execute = function() {
    var script;
    script = thumbses[index++];
    if ((script != null ? script.type : void 0) === 'text/thumbs') {
      if (script.src) {
        return Thumbs.load(script.src, execute);
      } else {
        Thumbs.run(script.innerHTML.slice(1), "scripttag" + (index - 1));
        return execute();
      }
    }
  })();
  return null;
};

if (window.addEventListener) {
  addEventListener('DOMContentLoaded', runScripts, false);
} else {
  attachEvent('onload', runScripts);
}
})();

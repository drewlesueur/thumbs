<!doctype html>
<style>
  * {
    font-family: Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Mono', 'Monospace'
  }
</style>
<script type="text/x-thumbs">
sayMessage * message
  Say message 

message $ my message
SayMessage message

answer Add 1 2
Say answer

</script>
<script type="text/x-thumbs-2">
$ everything is a function that does what it does??
$ or simple goto
mytext $
  this is a totally cool
  string that is verry long

mytext2 $ this is another text not as big

message $ hi
Say message
Say $HelloWorld
sayHi * name age
  Say age

snowman #
  eyes $carrots
  body $snow

snowman.mouth $pipe


mylist + long list of stuff

myname $ Drew LeSueur
myage 27
SayHi myname myage

answer Add 7 5

</script>
<h1>Thumbs. A simple programming language</h1>
What the symbols mean
<pre class="legend" style="font-size: 40px">
* function
# map (hash)
+ list (array)
$ text (string)
</pre>

A Hello world


<script type="text/javascript">

  var splitText = function (text) {
    text = text.split(" ");
    return text
  }

  var parse = function(configs) {
    var a, b, config, currentObj, currentSpaceLen, final, i, lastIndex, lastThingAdded, match, newCurrentObj, objectStack, ret, spaceLen, text, _i, _len, _ref;
    configs = configs.split("\n");
    final = {};
    currentSpaceLen = -2;
    lastThingAdded = ["do"];
    currentObj = [lastThingAdded];
    lastIndex = 0;
    objectStack = [currentObj];
    for (_i = 0, _len = configs.length; _i < _len; _i++) {
      config = configs[_i];
      match = config.match(/^(\s*)([^\s].*)/);
      if (!match) continue;
      if ((match != null ? match.length : void 0) < 3) continue;
      spaceLen = match[1].length / 2;
      text = match[2];
      text = splitText(text)
      text.unshift(_i) // for line numbers
      if (spaceLen === currentSpaceLen) {
        currentObj.push(text);
        lastThingAdded = text;
        lastIndex = currentObj.length - 1;
      } else if (spaceLen > currentSpaceLen) {
        currentSpaceLen = spaceLen;
        newCurrentObj = [lastThingAdded];
        currentObj[lastIndex] = newCurrentObj;
        currentObj = newCurrentObj;
        currentObj.push(text);
        lastThingAdded = text;
        lastIndex = currentObj.length - 1;
        objectStack.push(currentObj);
      } else if (spaceLen < currentSpaceLen) {
        for (i = 0, _ref = currentSpaceLen - spaceLen; 0 <= _ref ? i <= _ref : i >= _ref; 0 <= _ref ? i++ : i--) {
          currentObj = objectStack.pop();
        }
        try {
          currentObj.push(text);
        } catch (e) {

        }
        objectStack.push(currentObj);
        currentSpaceLen = spaceLen;
        lastThingAdded = text;
        lastIndex = currentObj.length - 1;
      }
    }
    window.os = objectStack;
    window.co = currentObj;
    ret = objectStack[0] || currentObj;
    console.log(ret);
    return ret[0];
  };

  var scope = {
    "say": function (x) {
      alert(x)
    },
    "do": function () {},
    "add": function (a, b) {
      return a + b;
    },
    parentScope: null
  }  
  window.scope = scope;
  var currentScope = scope;
  var scopeStack = [];
  window.scopeStack = scopeStack;
  window.currentScope = currentScope;


  var isFunction = function (obj) {
    return toString.call(obj) == '[object Function]';
  }
  var isObject = function (obj) {
    return obj === Object(obj);
  }

  var __slice = Array.prototype.slice;

  var execLine = function (line, currentScope) {
    var nestedArgs = []
    if (line[0] - 0 === line[0]) {
      //no nested args
    } else {
      nestedArgs = line.slice(1)   
      line = line[0];
    }
    var lineNumber = line[0]
    var first = line[1];
    var second = line[2];
    var rest = line.slice(3);
    var value; 

    var setString = function () {
      console.log("(setting a string)")
      for (var i = 0; i < nestedArgs.length; i++) {
        nestedArgs[i] = nestedArgs[i].slice(1).join(" ") //slice to remove line number
      } 
      value = rest.join(" ") 
      value += nestedArgs.join("\n")
    }
    var setNumber = function () {
      value = second - 0 
    }
    var setFunction = function () {
      var newScope = {}
      newScope.parentScope = currentScope
      value = {
        scope: newScope,
        type: "fn",
        args: rest,
        body: nestedArgs
      }
    }

    var setValue = function () {
      console.log("(setting a value)");
      if (second == "$") { //todo. do a faster way of converting to string //cache or something
        setString()
      } else if (second == "*") {
        setFunction()
      } else if (second.match(/\d+/)) {
        setNumber() 
      } else if (second.match(/^[A-Z]/)) {
        setFuncCall(); 
      }
      console.log ("Setting " + first + " to " + value)
      currentScope[first.toLowerCase()] =  value;
      return value
    }
    

    var callJSFunction = function () {
      rest = [second].concat(__slice.call(rest))
      for (var i = 0; i < rest.length; i++) {
        rest[i] = get(rest[i]) 
      } 
      //todo, convert objs and fns to js objs and fns
      return fn.apply(null, rest);
    }
    
    var callThumbsFunction = function (fn) {
      rest = [second].concat(__slice.call(rest))
      var args = []
      for (var i = 0; i < rest.length; i++) {
        var varName = rest[i]
        var argVarName = fn.args[i] 
        var argValue = get(varName, currentScope)
        args.push(argValue);
        if (argVarName) {
          fn.scope[argVarName] = argValue;
        }
      } 
      return runParsed(fn.body, fn.scope)
    }
    
    var setFuncCall = function () { //todo: maybe pass arguments here 
      var name = first  
      first = second
      second = rest[0]
      rest = rest.slice(1)
      value = callFunction()
      currentScope[name] = value 
    }

    var callFunction = function () {
      fn = get(first.toLowerCase()) 
      console.log("The function is ")
      console.log(first)
      console.log(fn)
      console.log("+++++++")
      console.log(rest[0])
      if (isFunction(fn)) {
        return callJSFunction()
      } else if (fn.type == "fn") {
        return callThumbsFunction(fn)  
      }
    }

    //TODO: get can be an object! change
    //TODO: also include getter and setter options
    var get = function (name, lookupScope) {
      if (isObject(name)) {
        var a = 1; 
      }

      if (name.charAt(0) == "$") {
        return name.substring(1) 
      } else if (name.match(/\d+/)) {
        return name - 0
      }

      name = name.toLowerCase()
      lookupScope = lookupScope || currentScope;
      if (name in lookupScope) {
        return lookupScope[name] 
      } else if (lookupScope.parentScope) {
        return get(name, lookupScope.parentScope) 
      } else {
        return null;
      }
    } 

    console.log(originalLines[lineNumber])
    if (first == "$") {
      console.log("(skipping)")
    } else if (first.match(/^[a-z]/)) {
      setValue()
    } else if (first.match(/^[A-Z]/)) {
      console.log("(calling a function)")
      return callFunction()
    }
  }
  
  var originalLines;
  var parsed;

  var runParsed = function (parsed, theScope) {
     theScope = theScope || currentScope
     var last;
     for (var i = 0; i < parsed.length; i++) {
       var line = parsed[i];
       last = execLine(line, theScope);
     }
     return last
  }

  var run = function (code) {
     parsed = parse(code);
     originalLines = code.split("\n")
     console.log(parsed);
     parsed = parsed.slice(1)
     runParsed(parsed);
  }

  var start = function () {
    var codes = document.querySelectorAll('[type="text/x-thumbs"]')
    console.log(codes);
    for (var i = 0; i < codes.length; i++) {
      var code = codes[i].innerHTML.slice(1)
      run(code)
    }
    console.log(scope)
  }
</script>
<body onload="start()">
  //todo. objects as keys
  //todo. splats! and create a new function with scope
</body>
